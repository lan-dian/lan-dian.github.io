(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{324:function(e,v,t){"use strict";t.r(v);var _=t(8),r=Object(_.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[e._v("#")]),e._v(" 是什么")]),e._v(" "),v("p",[e._v("Hbase是一个分布式数据库，可以存储互联网的海量数据。\nHBase是在HDFS的基础之上构建的，HDFS是分布式文件系统。\n可以支持千万的QPS、PB级别的存储。")]),e._v(" "),v("h2",{attrs:{id:"为什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么"}},[e._v("#")]),e._v(" 为什么")]),e._v(" "),v("blockquote",[v("p",[e._v("为什么不是MySql")])]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[e._v("HBase的")])]),e._v(" "),v("th",[v("strong",[e._v("关系数据库管理系统(RDBMS)")])])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("HBase是无架构的，它没有固定列架构的概念；仅定义列族。")]),e._v(" "),v("td",[e._v("RDBMS由其架构控制，该架构描述表的整个结构。")])]),e._v(" "),v("tr",[v("td",[e._v("它是"),v("strong",[e._v("为宽表而设计")]),e._v("的。HBase是水平可伸缩的。")]),e._v(" "),v("td",[e._v("它很薄，专为小表而建。难以扩展。")])]),e._v(" "),v("tr",[v("td",[e._v("HBase中"),v("strong",[e._v("没有事务")]),e._v("。")]),e._v(" "),v("td",[e._v("RDBMS是事务性的。")])]),e._v(" "),v("tr",[v("td",[e._v("它具有"),v("strong",[e._v("非规范化")]),e._v("的数据。")]),e._v(" "),v("td",[e._v("它将具有标准化的数据。")])]),e._v(" "),v("tr",[v("td",[e._v("对于半结构化数据和结构化数据都非常有用。")]),e._v(" "),v("td",[e._v("这对结构化数据很有用。")])])])]),e._v(" "),v("p",[e._v("因为Mysql无法存储互联网的海量数据，只能使用NoSql的解决方案。")]),e._v(" "),v("blockquote",[v("p",[e._v("为什么不是ES")])]),e._v(" "),v("p",[e._v("因为ES的成本比较好，支持了分词等等逻辑，主要用在搜索领域，远高于我们的需求。")]),e._v(" "),v("blockquote",[v("p",[e._v("为什么不是HDFS")])]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[e._v("HDFS")])]),e._v(" "),v("th",[v("strong",[e._v("HBase")])])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("HDFS是适用于存储大文件的分布式文件系统。")]),e._v(" "),v("td",[e._v("HBase是建立在HDFS之上的数据库。")])]),e._v(" "),v("tr",[v("td",[e._v("HDFS不支持快速的单个记录查找。")]),e._v(" "),v("td",[e._v("HBase为大型表提供快速查找。")])]),e._v(" "),v("tr",[v("td",[e._v("它提供高延迟的批处理；没有批处理的概念。")]),e._v(" "),v("td",[e._v("它提供了数十亿条记录对单行的低延迟访问（随机访问）。")])]),e._v(" "),v("tr",[v("td",[e._v("它仅提供数据的顺序访问。")]),e._v(" "),v("td",[e._v("HBase在内部使用哈希表并提供随机访问，并且将数据存储在索引的HDFS文件中，以加快查找速度。")])])])]),e._v(" "),v("p",[e._v("HDFS是一个分布式的文件系统，他可以存储海量的数据，但是功能太底层，不方便我们去操作。")]),e._v(" "),v("hr"),e._v(" "),v("p",[v("strong",[e._v("HBase可以以低成本来存储海量的数据并且支持高并发随机写和实时查询。")])]),e._v(" "),v("h2",{attrs:{id:"概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),v("h3",{attrs:{id:"列式存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#列式存储"}},[e._v("#")]),e._v(" 列式存储")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[e._v("面向行的数据库")])]),e._v(" "),v("th",[v("strong",[e._v("列式数据库")])])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("它适用于在线事务处理（OLTP）。")]),e._v(" "),v("td",[e._v("它适用于在线分析处理（OLAP）。")])]),e._v(" "),v("tr",[v("td",[e._v("此类数据库设计用于少量的行和列。")]),e._v(" "),v("td",[e._v("面向列的数据库是为大型表设计的。")])])])]),e._v(" "),v("p",[e._v("我们可以对比的去学习，MySQL是行存储，每一行有一个id，然后有若干字段。那列式存储，从形式上来看，就是就是把一行拆分开，每一行只有一个id和一个字段。\n这样做有什么好处吗，为什么要这么做？\n首先，在MySQL中如果有的字段为空，或者有的一列字段很多重复的，都会照成空间的浪费，如果是列式存储的话，这些空间都是可以压缩的。而且一个id对应一个字段这样的结构，就是NoSql最典型的k-v结构。")]),e._v(" "),v("h3",{attrs:{id:"基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[e._v("#")]),e._v(" 基本概念")]),e._v(" "),v("blockquote",[v("p",[e._v("表")])]),e._v(" "),v("p",[e._v("首先，Hbase里面也有表的概念这个和Mysql是一样的")]),e._v(" "),v("blockquote",[v("p",[e._v("行键(RowKey)")])]),e._v(" "),v("p",[e._v("这个其实就是id")]),e._v(" "),v("blockquote",[v("p",[e._v("列族")])]),e._v(" "),v("p",[e._v("一个列族下面有多个列")]),e._v(" "),v("p",[e._v("区别于MySql，有了列族的概念，而且行与行之间不需要相同的列。数据写到HBase的时候都会被记录一个时间戳，这个时间戳被我们当做一个版本。比如说，我们"),v("strong",[e._v("修改或者删除")]),e._v("某一条的时候，本质上是往里边"),v("strong",[e._v("新增")]),e._v("一条数据，记录的版本加一了而已。")]),e._v(" "),v("h2",{attrs:{id:"架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[e._v("#")]),e._v(" 架构")]),e._v(" "),v("p",[e._v("Client客户端，它提供了访问HBase的接口，并且维护了对应的cache来加速HBase的访问。\nZookeeper存储HBase的元数据（meta表），无论是读还是写数据，都是去Zookeeper里边拿到meta元数据告诉给客户端去哪台机器读写数据。\nHRegionServer它是处理客户端的读写请求，"),v("strong",[e._v("负责与HDFS底层交互")]),e._v("，是真正干活的节点。")]),e._v(" "),v("p",[e._v("大概的流程就是：client请求到Zookeeper，然后Zookeeper返回HRegionServer地址给client，client得到Zookeeper返回的地址去请求HRegionServer，HRegionServer读写数据后返回给client。")]),e._v(" "),v("h3",{attrs:{id:"hregionserver"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hregionserver"}},[e._v("#")]),e._v(" HRegionServer")]),e._v(" "),v("p",[e._v("很明显的，这个Server肯定是核心的内容。")]),e._v(" "),v("blockquote",[v("p",[e._v("HRegion")])]),e._v(" "),v("p",[e._v("HBase一张表的数据会分到多台机器上的。用的就是RowKey来切分，其实就是表的横向切割。一个HRegionServer上面管理了多个HRegion，存储了HBase表的一部分数据。")]),e._v(" "),v("blockquote",[v("p",[e._v("Store")])]),e._v(" "),v("p",[e._v("HRegion下面有Store，那Store是什么呢？我们前面也说过，一个HBase表首先要定义列族，然后列是在列族之下的，列可以随意添加。\n"),v("strong",[e._v("一个列族的数据是存储")]),e._v("在一起的，所以一个列族的数据是存储在一个Store里边的。")]),e._v(" "),v("blockquote",[v("p",[e._v("Store内部")])]),e._v(" "),v("p",[e._v("HBase在写数据的时候，"),v("strong",[e._v("会先写到Mem Store，当MemStore超过一定阈值，就会将内存中的数据刷写到硬盘上")]),e._v("，形成StoreFile，而"),v("strong",[e._v("StoreFile底层是以HFile的格式")]),e._v("保存，HFile是HBase中KeyValue数据的存储格式。\nMemStore的作用不是为了加快写速度，而是为了对Row Key进行排序。")]),e._v(" "),v("blockquote",[v("p",[e._v("Hlog")])]),e._v(" "),v("p",[e._v("这里看到了内存写入，我们学过MySQL原理的同学肯定第一时间就想到了内存有丢失的风险，同理，Hbase在解决这个问题的时候，也是通过一个顺序写日志的方式解决的，也就是HLog。顺序写磁盘，直接写内存，批量持久化内存，所以说性能还是非常高的。\n在HBase中，每个RegionServer只需要维护一个WAL，所有Region对象共用一个WAL，而不是每个Region都维护一个WAL。这种方式对于多个Region的更新操作所发生的的日志修改，只需要不断地追加到单个日志文件中，不需要同时打开并写入多个日志文件，这样可以减少磁盘寻址次数，提高写性能。")]),e._v(" "),v("blockquote",[v("p",[e._v("HMaster")])]),e._v(" "),v("p",[e._v("到这里我们还有一个最关键的点不知道，HRegion到底是怎么划分的呀，具体是谁管理的，那么这个时候就需要一个Master来管理了。\n"),v("strong",[e._v("首先，读写请求都不经过Hmaster")]),e._v("，只是为了管理。HMaster会处理 HRegion 的"),v("strong",[e._v("分配或转移")]),e._v("。如果我们HRegion的"),v("strong",[e._v("数据量太大的话")]),e._v("，HMaster会对"),v("strong",[e._v("拆分")]),e._v("后的Region重新分配RegionServer。（如果"),v("strong",[e._v("发现失效的HRegion")]),e._v("，也会将失效的HRegion分配到正常的HRegionServer中）\nMaster只负责各种协调工作，比如建表、删表、移动Region、合并等操作。这些操作有一个共性的问题：就是需要跨RegionServer。所以，HBase就将这些工作分配给了Master服务。这种结构的好处是大大降低了集群对Master的依赖。而Master节点一般只有一个到两个，一旦宕机，如果集群对Master的依赖度很大，那么就会产生单点故障问题。在HBase中即使Master宕机了，集群依然可以正常地运行，依然可以存储和删除数据。")])])}),[],!1,null,null,null);v.default=r.exports}}]);